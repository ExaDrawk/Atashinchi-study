# Replace QA character chat with level-graded fill-in drills

This ExecPlan is a living document. Maintain every section (Progress, Surprises & Discoveries, Decision Log, Outcomes & Retrospective) in accordance with `.agent/PLANS.md`.

## Purpose / Big Picture

Learners should no longer launch a character chat to discuss Q&A items. Instead, every question must offer a structured "ç©´åŸ‹ã‚å¼ã®è§£èª¬ä½œæˆ" flow with three difficulty levels. Each level generates a fill-in template, accepts free-form user input, scores it automatically with Gemini, and records success. Progress (cleared levels, latest template, attempts) must persist inside the moduleâ€™s JS file so the work survives reloads. Clearing a level instantly appends a detailed entry to ã€ŒğŸ“… ä»Šæ—¥ã®å­¦ç¿’è¨˜éŒ²ã€. Success is demonstrated by opening any case page, picking a Q&A, progressing through levels with AI-generated blanks, seeing pass/fail feedback inline, refreshing the page, and observing that cleared levels and study-log entries remain.

## Progress

- [x] (2024-09-16 04:10Z) Drafted this ExecPlan describing the required fill-in drill redesign, persistence rules, and validation strategy.
- [x] (2025-11-16 12:05Z) Remove QA chat UI/actions (`public/qaRenderer.js`, related event glue) and insert level chips + mount points without breaking tabs.
- [x] (2025-11-16 12:40Z) Add backend endpoints (`/api/qa-fill/generate`, `/api/qa-fill/grade`) plus shared helpers for Gemini prompts/JSON parsing with graceful 503 messaging when `GEMINI_API_KEY` is missing.
- [x] (2025-11-16 13:30Z) Implement `public/qaFillDrillSystem.js` to render level cards, fetch/cache templates, collect answers, call grading API, and expose global mount helpers.
- [x] (2025-11-16 13:45Z) Persist fillDrill progress via `QAStatusSystem.saveQADataToFile`, auto-post study logs with `title/detail/qaId/level`, and surface the new fields on the home dashboard + calendar.
- [ ] (2024-09-16 09:00Z) Validate end-to-end: manual UX pass, `npm run build` (note existing case parse errors), smoke `npm start`, and update README if any workflows changed.

## Surprises & Discoveries

- None yet. Record future API quirks, AI response oddities, or file-format gotchas here with short evidence snippets.

## Decision Log

- Decision: Store fill-in progress directly on each `questionsAndAnswers` entry under a new `fillDrill` object instead of a separate JSON file.
  Rationale: The server already persists Q&A metadata by rewriting the module file through `/api/update-qa-status`, so keeping all per-QA state co-located avoids another storage layer and keeps study data near the source material.
  Date/Author: 2024-09-16 / Copilot
- Decision: Keep existing story/è§£èª¬ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½ powered by `chatSystem.js`, but remove only the Q&A-specific ğŸ¤” button and hooks.
  Rationale: The requirement targets Q&Aã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒãƒ£ãƒƒãƒˆå»ƒæ­¢ã®ã¿ã§ã€ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ï¼è«–æ–‡ã‚¿ãƒ–ã®ä¼šè©±ãƒ¢ãƒ¼ãƒ‰ã¯ç¾è¡Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¾å­˜ã—ã¦ã„ã‚‹ãŸã‚æ®‹ã™ã€‚
  Date/Author: 2025-11-16 / Copilot

## Outcomes & Retrospective

**2025-11-17 æ¡ç‚¹ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ–¹é‡å¤‰æ›´**
- **è¦ä»¶**: å¸æ³•è©¦é¨“è«–æ–‡å¼å¯¾ç­–ã¨ã—ã¦ã€èª¤ç­”æ™‚ã«æ¨¡ç¯„è§£ç­”ã‚’ä¸€åˆ‡æç¤ºã›ãšã€æ·±ã„ç†è§£ã«ã¤ãªãŒã‚‹ãƒ’ãƒ³ãƒˆã®ã¿ã‚’ç¤ºã™ã€‚ã€Œä½•ãŒãƒ»ã©ã®ã‚ˆã†ã«ãƒ»ãªãœã€é–“é•ã£ã¦ã„ã‚‹ã‹ã‚’å—è¬›è€…è‡ªèº«ã«è€ƒãˆã•ã›ã‚‹ã€‚
- **å®Ÿè£…å†…å®¹**:
  - `buildGradingPrompt`ã§Geminiã«ã€Œæ¨¡ç¯„è§£ç­”ã‚„æ­£è§£èªå¥ã‚’æç¤ºã—ã¦ã¯ãªã‚‰ãªã„ã€ã€Œæ¡æ–‡ãƒ»åˆ¤ä¾‹ã¸ã®èª˜å°ãƒ’ãƒ³ãƒˆã®ã¿ã€ã‚’æŒ‡ç¤ºã™ã‚‹æ–°ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã€‚
  - `/api/qa-fill/grade`ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰`expected`ã€`canonicalAnswer`ã€`canonicalBlanks`ã‚’é™¤å»ã€‚
  - `public/qaFillDrillSystem.js`ã®è©•ä¾¡ãƒ–ãƒ­ãƒƒã‚¯ã«ã€ŒğŸ’¡ è‡ªå·±è§£èª¬ã®ãƒ’ãƒ³ãƒˆã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã—ã€ã€Œä½•ãŒ/ã©ã®ã‚ˆã†ã«/ãªãœã€ã‚’ä¿ƒã™ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã€‚
- **é”æˆ**: æ¡ç‚¹å¾Œã®UIã¯æ­£è§£ã‚’ç›´æ¥æ•™ãˆãšã€ã€Œæ¡æ–‡â—‹æ¡ã®æ–‡è¨€ã‚’ç¢ºèªã€ã€Œåˆ¤ä¾‹ãŒé‡è¦–ã—ãŸè¦–ç‚¹ã¯ä½•ã‹ã€ç­‰ã®æ¢ç´¢æŒ‡ç¤ºã®ã¿ã€‚æ¨¡ç¯„è§£ç­”ã‚’è¦‹ã‚‹å‰ã«è‡ªå·±ä¿®æ­£ã•ã›ã‚‹å¸æ³•è©¦é¨“è«–æ–‡å¯¾ç­–ã«æœ€é©åŒ–å®Œäº†ã€‚

## Context and Orientation

The case detail page (`public/pages/casePage.js`) renders tabs (story, quiz, Q&A, etc.) and wires global handlers via `public/eventHandler.js`. Q&A cards come from `public/qaRenderer.js`, which currently injects a ğŸ¤” chat button that calls `startChatSession` in `public/chatSystem.js`. Blank spans are generated by `processBlankFillText` in `public/articleProcessor.js`. Q&A statuses persist by editing each module file through `QAStatusSystem.saveQADataToFile`, which calls the server endpoint `/api/update-qa-status` implemented in `server.js`. Study logs live inside each moduleâ€™s `studyRecords` array and feed the home dashboard (`public/pages/homePage.js`) via `/api/add-study-record`, `/api/get-study-record`, and `/api/calendar-study-records`. There is already infrastructure for fetching Gemini responses via `/api/gemini`. We will remove the QA chat path, introduce new fill-drill UI wiring, and add backend endpoints to generate templates and grade answers while updating the persistence hooks and daily log display.

## Plan of Work

1. **Retire QA chat affordances and add drill placeholders.** Remove the ğŸ¤” button and related attributes from `public/qaRenderer.js`, strip chat-specific listeners from `public/eventHandler.js`, and stop importing `chatSystem.js` in `public/app.js` and `public/pages/casePage.js`. In `renderQAItem`, add a `<div class="qa-fill-drill" data-qa-id="â€¦">` plus summary chips showing blank count and current cleared levels. Ensure `setupQAListEventHandlers` invokes a new global `window.qaFillDrillSystem.mount(container)` after rendering.

2. **Backend: template generation and grading services.** In `server.js` add utility helpers (`normalizeJPText`, `safeGeminiJSONParse`) near the Gemini section. Create `POST /api/qa-fill/generate` that accepts `{ relativePath, qaId, level, historySnapshot }`, builds a prompt describing the case context (question, canonical answer text with blanks resolved via `processArticleReferences` on the server, relevant law tags), enforces a JSON-only response with fields (`level`, `focus`, `sections`, `blanks`, `evaluationRubric`, `writingGoals`), and caches the latest template in memory keyed by `relativePath+qaId+level` for quick retries. Create `POST /api/qa-fill/grade` that takes `{ template, answers, level }`, performs quick local checks (exact match ignoring punctuation) and, when uncertain, asks Gemini to return `{ overall, blanks: [...] }` with pass/fail per blank plus textual feedback. Both routes must gracefully report when `GEMINI_API_KEY` is absent and should propagate status codes so the UI can show actionable errors.

3. **Front-end fill-drill system.** Add `public/qaFillDrillSystem.js` exporting `initQAFillDrills(container)` and attach it to `window`. Responsibilities: render compact cards under each Q&A summarizing level status (color-coded dots, timestamps), lazy-load templates when a user opens a level, display the AI-provided sections with `[B#]` placeholders turned into `input`/`textarea` elements, list hints for each blank, offer reset/regenerate buttons, and collect answers for submission. Show inline chip feedback after grading, highlight correct blanks, and if the level passes (all blanks true or level 3 overall pass), show a celebratory banner plus a â€œæ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸â€ button. All UI must be keyboard-accessible and reuse existing Tailwind utility classes.

4. **Persistence and logging.** Extend `qaFillDrillSystem` to mutate `window.currentCaseData.questionsAndAnswers[index].fillDrill` with structure `{ clearedLevels: number[], pendingTemplate: {...}, lastAttempt: {...} }`. Reuse `QAStatusSystem.saveQADataToFile(relativePath, questionsAndAnswers)` so that edits hit `/api/update-qa-status`. Update `/api/add-study-record` and `generateStudyRecordsArrayString` in `server.js` to keep optional `title`, `detail`, `qaId`, `level` fields, and ensure `/api/calendar-study-records` forwards them to the client. When a level is cleared, call `/api/add-study-record` with `title` formatted like `Q2 ãƒ¬ãƒ™ãƒ«1ã‚¯ãƒªã‚¢` and `detail` summarizing the concept, then invalidate the home dashboard cache via `window.updateSingleStudyRecord`. Also add a lightweight append to `learning-logs/<YYYY-MM-DD>.md` noting the module, QA, and level (new helper near `ensureLogsDirectory`).

5. **Validation, docs, and cleanup.** Remove dead chat exports (`startChatSession`, etc.) if unused elsewhere, and delete the file if no other mode relies on it. Update `README.md` (or relevant UX docs) to describe the new workflow, required environment variable, and fallback when Gemini is unavailable. Run `npm run build` (document that it still fails on pre-existing case syntax warnings) and `npm start` for a smoke test where you complete Level 1 on a sample QA, refresh, and confirm persistence plus daily log entries.

## Concrete Steps

1. Remove chat imports/buttons/events: edit `public/qaRenderer.js`, `public/eventHandler.js`, `public/pages/casePage.js`, and `public/app.js`, adding the new drill placeholder markup and calling `window.qaFillDrillSystem` after rendering.
2. Backend work in `server.js`: add shared helper functions near the Gemini section; define the two new POST routes with robust validation, caching, and JSON-only responses; wire them into Express before the SPA catch-all.
3. Create `public/qaFillDrillSystem.js` with: state cache keyed by module+qa, DOM builders for level cards, fetch helpers that call the new routes, text-input renderers for `[B#]` tokens, and success/error toasts (reuse `showNotification`). Import this module inside `public/app.js` so it registers globally.
4. Update persistence: extend `QAStatusSystem` (if needed) to expose `saveQADataToFile` and new helpers for retrieving `fillDrill`. When marking a level complete, update the in-memory QA object, write the array back via the existing API, and POST to `/api/add-study-record` with `title/detail` plus `learning-logs` append.
5. Client log display: adjust `public/pages/homePage.js` (and any other UI that reads `studyEntries`) to display `record.title` / `record.detail` if present so the daily log card shows which level was cleared.
6. Testing: from repo root run `npm run build` (document the known `public/cases` parse errors that pre-exist) and `npm start`, then in a browser complete Level 1 for an arbitrary QA, reload, and confirm the UI still shows Level 1 cleared and the home page lists the new study record.

## Validation and Acceptance

- **Backend:** `npm run build` should still finish with the pre-existing case-file parsing errors only; no new stack traces referencing the new endpoints. When `npm start` is running, `POST /api/qa-fill/generate` with a sample payload should return deterministic JSON (validate via `curl` if needed). If `GEMINI_API_KEY` is missing, responses must include an explanatory message and HTTP 503.
- **Front-end:** On a case page, each Q&A shows Level 1â€“3 chips instead of the chat button. Starting Level 1 fetches a template, renders blanks, and entering correct keywords yields per-blank âœ… feedback. Passing a level disables its inputs, unlocks the next level, and shows a toast plus a banner referencing the logged study record. Reloading the page preserves cleared levels thanks to the stored `fillDrill` data.
- **Daily log:** After clearing a level, open the home pageã€ŒğŸ“… ä»Šæ—¥ã®å­¦ç¿’è¨˜éŒ²ã€ to see an entry like â€œQ2 ãƒ¬ãƒ™ãƒ«1ã‚¯ãƒªã‚¢â€ with a timestamp matching the completion event. The calendar hover should also include this detail. Deleting the log entry via the existing UI should continue to work because the server now preserves custom fields when rewriting `studyRecords`.

## Idempotence and Recovery

Generating a level template or grading answers is safe to repeat; cache keys prevent duplicate Gemini costs until the user clicks "å†ç”Ÿæˆ". Saving progress rewrites the entire `questionsAndAnswers` array, so always mutate a cloned array and retry the `/api/update-qa-status` call if it fails. If a fill-drill save partially fails (e.g., server rejected the write), reload the case to resync and retryâ€”the previous file content remains intact. Study-record writes remain append-or-update per date; posting the same completion twice on the same day simply updates the timestamp and detail string.

## Artifacts and Notes

Capture sanitized transcripts of: (a) the JSON emitted by `/api/qa-fill/generate` for a sample QA, (b) the grading response showing per-blank scores, (c) the `npm run build` log snippet demonstrating no new errors beyond the known case-file parse failures. Include screenshots or textual descriptions of the new UI in the Outcomes section when finished.

## Interfaces and Dependencies

- **Server modules:**
    - `POST /api/qa-fill/generate(body: { relativePath: string, qaId: number, level: 1|2|3, historySnapshot?: object }) -> { template }`
    - `POST /api/qa-fill/grade(body: { relativePath: string, qaId: number, level: 1|2|3, template: TemplateShape, answers: [{ id: string, text: string }] }) -> { overall: { passed: boolean, score: number }, blanks: [{ id: string, passed: boolean, score: number, feedback: string }], suggestions: string[] }`
    - Helper `normalizeJPText(input: string, { ignoreKanaCase?: boolean }) -> string` and `safeGeminiJSONParse(text: string) -> any` shared by both routes.

- **Client state:**
    - Each `questionsAndAnswers` entry gains `fillDrill?: { clearedLevels: number[], pendingTemplate?: TemplateShape, lastAttempt?: { level: number, timestamp: string, answers: Record<string,string>, result: object } }`.
    - `window.qaFillDrillSystem = { mount(container: HTMLElement), refreshOne(qaId: number) }` for reuse after dynamic rerenders.
    - Study record API now stores `title`, `detail`, `qaId`, and `level` so `homePage.js` can display them without additional lookups.

Document any additional helper signatures discovered during implementation to keep this section authoritative.

---
Initial version created 2024-09-16 by Copilot to replace QA chat with level-based fill-in drills.
